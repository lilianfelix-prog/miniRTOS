# FreeRTOS RISC-V Build Process Analysis

## Overview
Thie RISC-V_RV32_QEMU_VIRT_GCC makefile builds a FreeRTOS kernel image (`RTOSDemo.elf`) for RISC-V architecture, specifically targeting QEMU's virtual RISC-V machine. Here is some deduced information from it that will help me understand what I need for my kernel (generated by claude sonnet 4).

## Prerequisites & Dependencies

### Required Tools
- **riscv64-unknown-elf-gcc**: Cross-compiler for RISC-V 64-bit
- **riscv64-unknown-elf-size**: For displaying binary size information
- **make**: Build system
- **QEMU RISC-V virtual machine** (implied target)

### Required Files & Directories
- **FreeRTOS source tree**: Must be located 4 directories up (`../../../../`)
- **Linker script**: `fake_rom.ld` (defines memory layout)
- **Assembly startup files**: `start.S`, `RegTest.S`, `vector.S`
- **Platform-specific code**: `printf-stdarg.c`, `ns16550.c`, `riscv-virt.c`

## Architecture Configuration

### Build Variants
The makefile supports two build configurations:

#### 1. RVA23 Profile (64-bit) - When `RVA23=1`
```
Architecture: rv64imafdcv_zicsr_zicntr_zihpm_ziccif_ziccrse_ziccamoa_zicclsm_za64rs_zihintpause_zic64b_zicbom_zicbop_zicboz_zfhmin_zkt_zvfhmin_zvbb_zvkt_zihintntl_zawrs
ABI: lp64d (64-bit pointers, double-precision floating point)
Code Model: medany (medium addressing, position independent)
Features: FPU and Vector Processing Unit enabled
```

#### 2. RV32 Profile (32-bit) - Default
```
Architecture: rv32imac_zicsr (or rv32imac for older GCC)
ABI: ilp32 (32-bit integers, longs, pointers)
Code Model: medlow (medium addressing, lower addresses)
Features: Integer, Multiply, Atomic, Compressed instructions
```

## Compilation Process

### Phase 1: Architecture Detection & Setup
1. **GCC Version Check**: Determines if `_zicsr` extension is needed
2. **Profile Selection**: Sets MARCH, MABI, MCMODEL based on RVA23 flag
3. **Library Selection**: Chooses between picolibc or nosys specs

### Phase 2: Source File Collection

#### FreeRTOS Kernel Sources
```
- tasks.c          (Core task management)
- list.c           (Linked list utilities)  
- queue.c          (Inter-task communication)
- timers.c         (Software timers)
- event_groups.c   (Event synchronization)
- stream_buffer.c  (Stream data structures)
- heap_4.c         (Memory management)
- port.c           (RISC-V specific port)
- portASM.S        (Assembly context switching)
```

#### Demo/Test Sources
Multiple test modules for validating kernel functionality:
- Queue operations (BlockQ.c, PollQ.c, QPeek.c)
- Semaphore tests (semtest.c, countsem.c)
- Task notifications (TaskNotify.c, TaskNotifyArray.c)
- Memory management (dynamic.c, StaticAllocation.c)
- And many more...

#### Platform-Specific Sources
```
- main.c, main_blinky.c, main_full.c (Application entry points)
- ns16550.c        (UART driver for console I/O)
- riscv-virt.c     (QEMU virt machine setup)
- printf-stdarg.c  (Lightweight printf implementation)
- start.S          (Boot/startup assembly)
- RegTest.S        (Register testing routines)
- vector.S         (Interrupt vector table)
```

### Phase 3: Compilation
Each source file is compiled with:
```bash
riscv64-unknown-elf-gcc [CFLAGS] -MMD -MP -c source.c -o output/source.o
```

#### Key Compiler Flags
- **-march=$(MARCH)**: Target architecture specification
- **-mabi=$(MABI)**: ABI specification
- **-mcmodel=$(MCMODEL)**: Code model for addressing
- **-ffunction-sections -fdata-sections**: Enable dead code elimination
- **-nostartfiles**: Don't use standard startup files
- **-g3**: Maximum debug information
- **-Os**: Optimize for size
- **-MMD -MP**: Generate dependency files

### Phase 4: Linking
```bash
riscv64-unknown-elf-gcc [OBJECT_FILES] [LDFLAGS] -o RTOSDemo.elf
```

#### Critical Linker Configuration
- **-T./fake_rom.ld**: Custom linker script defining memory layout
- **--defsym=__stack_size=352**: Stack size definition (352 bytes)
- **--gc-sections**: Remove unused sections
- **-Wl,-Map,RTOSDemo.map**: Generate memory map file

#### Library Wrapping
The makefile wraps many standard C library functions:
```
malloc, free, open, read, write, printf, etc.
```
This allows FreeRTOS to provide its own implementations or redirect to semihosting.

## Memory Configuration

### Stack Size
- **Fixed stack**: 352 bytes (quite small, typical for embedded)
- **Heap**: Managed by FreeRTOS heap_4.c algorithm

### Memory Layout
Defined by `fake_rom.ld` linker script (not shown, but critical):
- ROM/Flash regions for code
- RAM regions for data/stack/heap
- Memory-mapped I/O regions

## Build Output

### Primary Artifacts
1. **RTOSDemo.elf**: Main executable image
2. **RTOSDemo.map**: Memory layout map
3. **Object files**: Individual compiled modules
4. **Dependency files**: Build dependency tracking

### Size Information
The `riscv64-unknown-elf-size` tool displays:
- Text section size (code)
- Data section size (initialized variables)
- BSS section size (uninitialized variables)

## Build Process Flow

```
1. Parse build configuration (RVA23 vs RV32)
2. Set architecture-specific flags
3. Collect all source files from multiple directories
4. Compile each .c file to .o with dependency tracking
5. Assemble each .S file to .o
6. Link all objects with custom linker script
   =>   -Xlinker option
        Pass option as an option to the linker. You can use this to supply system-specific linker options that GCC does not recognize.
        If you want to pass an option that takes a separate argument, you must use -Xlinker twice, once for the option and once for the argument. For example, to pass -assert definitions, you must write -Xlinker -assert -Xlinker definitions. It does not work to write -Xlinker "-assert definitions", because this passes the entire string as a single argument, which is not what the linker expects.
        When using the GNU linker, it is usually more convenient to pass arguments to linker options using the option=value syntax than as separate arguments. For example, you can specify -Xlinker -Map=output.map rather than -Xlinker -Map -Xlinker output.map. Other linkers may not support this syntax for command-line options.
        from: https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html
7. Generate size report
8. Output final ELF image ready for QEMU
```

## Key Design Decisions

### Modular Architecture
- Clean separation between kernel, demos, and platform code
- Configurable build profiles for different RISC-V implementations
- Optional components (picolibc vs nosys, full vs blinky demos)

### Embedded Optimizations
- Size optimization (-Os)
- Dead code elimination
- Custom lightweight printf
- Minimal stack allocation
- No standard startup files

### Development Support
- Comprehensive test suite inclusion
- Debug symbol generation
- Dependency tracking for incremental builds
- Memory map generation for debugging

This makefile creates a complete, bootable FreeRTOS system specifically tuned for RISC-V virtual machines, with extensive testing capabilities and flexible configuration options.